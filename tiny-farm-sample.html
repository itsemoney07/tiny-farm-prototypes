<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tiny Farm — Sample Prototype</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM (development builds) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel so we can write JSX inline -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-emerald-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    // --- Constants/Types ---
    const WIDTH = 12;
    const HEIGHT = 12;
    const TICK_MS = 250;
    const DAY_LENGTH_TICKS = 4 * 60 * (1000 / TICK_MS);

    const TILE = {
      GRASS: "grass",
      TILLED: "tilled",
    };

    const STAGE = {
      SEED: 0,
      SPROUT: 1,
      GROWING: 2,
      MATURE: 3,
    };

    function makeEmptyMap() {
      return Array.from({ length: HEIGHT }, (_, y) =>
        Array.from({ length: WIDTH }, (_, x) => ({
          base: TILE.GRASS,
          crop: null,
          rock: Math.random() < 0.04,
          tree: Math.random() < 0.03,
        }))
      );
    }

    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

    function stageEmoji(stage) {
      switch (stage) {
        case STAGE.SEED: return "🌱";
        case STAGE.SPROUT: return "🌿";
        case STAGE.GROWING: return "🪴";
        case STAGE.MATURE: return "🌾";
        default: return "";
      }
    }

    function tileEmoji(tile) {
      if (tile.tree) return "🌳";
      if (tile.rock) return "🪨";
      if (tile.crop) return stageEmoji(tile.crop.stage);
      return tile.base === TILE.TILLED ? "🟫" : "🟩";
    }

    const canWalk = (tile) => !tile.tree && !tile.rock;
    const nextStage = (s) => clamp(s + 1, STAGE.SEED, STAGE.MATURE);

    function useKeyPresses() {
      const keysRef = useRef(new Set());
      useEffect(() => {
        const down = (e) => keysRef.current.add(e.key.toLowerCase());
        const up = (e) => keysRef.current.delete(e.key.toLowerCase());
        window.addEventListener("keydown", down);
        window.addEventListener("keyup", up);
        return () => {
          window.removeEventListener("keydown", down);
          window.removeEventListener("keyup", up);
        };
      }, []);
      return keysRef;
    }

    function Bar({ label, value, max }) {
      const pct = Math.round((value / max) * 100);
      return (
        <div>
          <div className="flex justify-between text-sm mb-1">
            <span className="font-medium">{label}</span>
            <span>{pct}%</span>
          </div>
          <div className="w-full h-3 bg-slate-200 rounded-full overflow-hidden">
            <div className="h-full bg-emerald-500" style={{ width: pct + "%" }} />
          </div>
        </div>
      );
    }

    function Stat({ label, value }) {
      return (
        <div className="p-3 bg-white rounded-2xl shadow flex items-center justify-between">
          <span className="text-sm text-slate-500">{label}</span>
          <span className="font-semibold">{value}</span>
        </div>
      );
    }

    function Footer({ day }) {
      return (
        <div className="text-xs text-slate-500 mt-3">
          Day {day} · Prototype build · Made with React & Tailwind
        </div>
      );
    }

    function TinyFarm() {
      const [map, setMap] = useState(makeEmptyMap);
      const [player, setPlayer] = useState({ x: 2, y: 2, stamina: 100 });
      const [inv, setInv] = useState({ seeds: 6, crops: 0, water: 100, gold: 0 });
      const [tick, setTick] = useState(0);
      const [paused, setPaused] = useState(false);

      const keysRef = useKeyPresses();

      const day = Math.floor(tick / DAY_LENGTH_TICKS) + 1;
      const dayProgress = (tick % DAY_LENGTH_TICKS) / DAY_LENGTH_TICKS;
      const isNight = dayProgress > 0.7 || dayProgress < 0.1;

      useEffect(() => {
        const id = setInterval(() => setTick((t) => t + 1), TICK_MS);
        return () => clearInterval(id);
      }, []);

      useEffect(() => {
        if (paused) return;
        const keys = keysRef.current;
        const dir = { x: 0, y: 0 };
        if (keys.has("arrowup") || keys.has("w")) dir.y -= 1;
        if (keys.has("arrowdown") || keys.has("s")) dir.y += 1;
        if (keys.has("arrowleft") || keys.has("a")) dir.x -= 1;
        if (keys.has("arrowright") || keys.has("d")) dir.x += 1;

        if (dir.x !== 0 || dir.y !== 0) {
          const nx = clamp(player.x + dir.x, 0, WIDTH - 1);
          const ny = clamp(player.y + dir.y, 0, HEIGHT - 1);
          const dest = map[ny][nx];
          if (canWalk(dest)) setPlayer((p) => ({ ...p, x: nx, y: ny }));
        }

        if (keys.has("f")) actTill();
        if (keys.has("g")) actPlant();
        if (keys.has("h")) actWater();
        if (keys.has("e")) actHarvest();
        if (keys.has("r")) actRemove();
        if (keys.has(".")) setTick((t) => t + 6);
      }, [tick, paused]);

      useEffect(() => {
        if (paused) return;
        if (tick % 8 !== 0) return;
        setMap((prev) => {
          const next = prev.map((row) => row.map((t) => ({ ...t, crop: t.crop ? { ...t.crop } : null })));
          for (let y = 0; y < HEIGHT; y++) {
            for (let x = 0; x < WIDTH; x++) {
              const t = next[y][x];
              if (!t.crop) continue;
              const c = t.crop;
              const chance = c.watered ? 0.7 : 0.25;
              if (Math.random() < chance && c.stage < STAGE.MATURE) {
                c.stage = c.stage + 1;
                if (c.stage > STAGE.MATURE) c.stage = STAGE.MATURE;
                c.watered = false;
              }
            }
          }
          return next;
        });
      }, [tick, paused]);

      const inBounds = (x, y) => x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT;

      function mutateTile(x, y, fn) {
        setMap((prev) => {
          if (!inBounds(x, y)) return prev;
          const next = prev.map((row) => row.slice());
          next[y] = next[y].map((t) => ({ ...t }));
          next[y][x] = fn({ ...next[y][x] });
          return next;
        });
      }

      const currentTile = () => map[player.y][player.x];

      function spendStamina(cost) {
        if (player.stamina < cost) return false;
        setPlayer((p) => ({ ...p, stamina: p.stamina - cost }));
        return true;
      }

      function actTill() {
        const t = currentTile();
        if (!canWalk(t)) return;
        if (t.base === TILE.TILLED) return;
        if (!spendStamina(2)) return;
        mutateTile(player.x, player.y, (tile) => ({ ...tile, base: TILE.TILLED }));
      }

      function actPlant() {
        const t = currentTile();
        if (t.base !== TILE.TILLED || t.crop || inv.seeds <= 0) return;
        if (!spendStamina(1)) return;
        setInv((i) => ({ ...i, seeds: i.seeds - 1 }));
        mutateTile(player.x, player.y, (tile) => ({
          ...tile,
          crop: { stage: STAGE.SEED, plantedAt: tick, watered: false },
        }));
      }

      function actWater() {
        const t = currentTile();
        if (!t.crop || inv.water <= 0) return;
        setInv((i) => ({ ...i, water: Math.max(0, i.water - 1) }));
        mutateTile(player.x, player.y, (tile) => ({ ...tile, crop: { ...tile.crop, watered: true } }));
      }

      function actHarvest() {
        const t = currentTile();
        if (!t.crop || t.crop.stage !== STAGE.MATURE) return;
        if (!spendStamina(1)) return;
        setInv((i) => ({ ...i, crops: i.crops + 1, gold: i.gold + 5 }));
        mutateTile(player.x, player.y, (tile) => ({ ...tile, crop: null }));
      }

      function actRemove() {
        const t = currentTile();
        if (t.rock) {
          if (!spendStamina(10)) return;
          mutateTile(player.x, player.y, (tile) => ({ ...tile, rock: false }));
          return;
        }
        if (t.tree) {
          if (!spendStamina(12)) return;
          mutateTile(player.x, player.y, (tile) => ({ ...tile, tree: false }));
          return;
        }
        if (t.crop && t.crop.stage < STAGE.MATURE) {
          if (!spendStamina(2)) return;
          mutateTile(player.x, player.y, (tile) => ({ ...tile, crop: null }));
        }
      }

      function rest() {
        setPlayer((p) => ({ ...p, stamina: 100 }));
        setInv((i) => ({ ...i, water: 100 }));
      }

      const overlayStyle = useMemo(() => {
        const darkness = isNight ? 0.4 : 0.1;
        return {
          boxShadow: `inset 0 0 0 9999px rgba(0,0,0,${darkness})`,
          transition: "box-shadow 300ms",
        };
      }, [isNight]);

      return (
        <div className="min-h-screen w-full bg-emerald-50 text-slate-800 flex flex-col items-center p-6">
          <div className="max-w-5xl w-full grid grid-cols-1 lg:grid-cols-3 gap-4">
            <div className="lg:col-span-1">
              <h1 className="text-3xl font-bold mb-2">🌾 Tiny Farm</h1>
              <div className="text-sm mb-2">Day <span className="font-semibold">{day}</span> · {isNight ? "Night" : "Daytime"}</div>
              <div className="space-y-2">
                <Bar label="Stamina" value={player.stamina} max={100} />
                <Bar label="Water" value={inv.water} max={100} />
              </div>
              <div className="mt-4 grid grid-cols-2 gap-2">
                <Stat label="Seeds" value={inv.seeds} />
                <Stat label="Crops" value={inv.crops} />
                <Stat label="Gold" value={inv.gold} />
              </div>
              <div className="mt-6 p-3 bg-white rounded-2xl shadow">
                <h2 className="font-semibold mb-2">Controls</h2>
                <ul className="text-sm list-disc pl-4 space-y-1">
                  <li>Move: WASD / Arrows</li>
                  <li>Till: F · Plant: G · Water: H</li>
                  <li>Harvest: E · Remove rock/tree/crop: R</li>
                  <li>Wait a moment: . (period)</li>
                  <li>Pause: P (coming soon) · Rest: click the bed</li>
                </ul>
              </div>
            </div>

            <div className="lg:col-span-2">
              <div className="relative">
                <div className="grid grid-cols-12 gap-1 bg-emerald-200 p-2 rounded-2xl shadow">
                  {map.map((row, y) => (
                    <React.Fragment key={y}>
                      {row.map((t, x) => {
                        const isPlayer = /* player on this tile */ (player.x === x && player.y === y);
                        return (
                          <div
                            key={x + "-" + y}
                            className={
                              "aspect-square rounded-xl flex items-center justify-center text-xl select-none " +
                              (t.base === TILE.TILLED ? "bg-amber-200" : "bg-emerald-300") + " " +
                              ((t.tree || t.rock) ? "opacity-90 " : "") +
                              (isPlayer ? "ring-4 ring-sky-500" : "")
                            }
                            style={{ position: "relative" }}
                          >
                            <span className="pointer-events-none">
                              {isPlayer ? "🧑‍🌾" : tileEmoji(t)}
                            </span>
                          </div>
                        );
                      })}
                    </React.Fragment>
                  ))}
                </div>
                <div className="absolute inset-0 rounded-2xl" style={overlayStyle} />
                <button
                  onClick={rest}
                  className="absolute -right-4 -top-4 bg-white border rounded-xl px-3 py-1 shadow hover:shadow-md"
                  title="Rest to recover stamina & refill water"
                >🛏️ Rest</button>
              </div>
              <Footer day={day} />
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<TinyFarm />);
  </script>
</body>
</html>
